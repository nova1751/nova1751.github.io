/*! postcss-smart-import v0.5.1 by undefined */
import _Promise from 'babel-runtime/core-js/promise';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import _typeof from 'babel-runtime/helpers/typeof';
import path from 'path';
import assign from 'object-assign';
import postcss from 'postcss';
import resolve from 'resolve';
import readCache from 'read-cache';
import valueParser from 'postcss-value-parser';
import promiseEach from 'promise-each';

var moduleDirectories = ["web_modules", "node_modules"];

function resolveModule(id, opts) {
  return new _Promise(function (res, rej) {
    resolve(id, opts, function (err, path$$1) {
      if (err) return rej(err);

      res(path$$1);
    });
  });
}

var resolveId = function (id, base, options) {
  var paths = options.path;

  var resolveOpts = {
    basedir: base,
    moduleDirectory: moduleDirectories,
    paths: paths,
    extensions: [".css", ".sss", ".less", ".scss", ".sass"],
    packageFilter: function processPackage(pkg) {
      if (pkg.style) {
        pkg.main = pkg.style;
      } else if (pkg.browser) {
        pkg.main = pkg.browser;
      } else if (!pkg.main || !/\.css$/.test(pkg.main)) {
        pkg.main = "index.css";
      }
      return pkg;
    }
  };

  return resolveModule("./" + id, resolveOpts).catch(function () {
    return resolveModule(id, resolveOpts);
  }).catch(function () {
    if (paths.indexOf(base) === -1) {
      paths.unshift(base);
    }

    throw new Error(["Failed to find '" + id + "'", "in [ ", "    " + paths.join(",\n        "), "]"].join("\n    "));
  });
};

function loadContent(filename) {
  return readCache(filename, "utf-8");
}

var stringify = valueParser.stringify;

var parseStatements = function (result, styles) {
  var statements = [];
  var nodes = [];

  styles.each(function (node) {
    var stmt;
    if (node.type === "atrule" && node.name === "import") stmt = parseImport(result, node);

    if (stmt) {
      if (nodes.length) {
        statements.push({
          type: "nodes",
          nodes: nodes
        });
        nodes = [];
      }

      statements.push(stmt);
    } else {
      nodes.push(node);
    }
  });

  if (nodes.length) {
    statements.push({
      type: "nodes",
      nodes: nodes
    });
  }

  return statements;
};

function parseImport(result, atRule) {
  var prev = atRule.prev();
  while (prev && prev.type === "comment") {
    prev = prev.prev();
  }

  if (prev) {
    if (prev.type !== "atrule" || prev.name !== "import" && prev.name !== "charset") {
      return result.warn("@import must precede all other statements (besides @charset)", { node: atRule });
    }
  }

  if (atRule.nodes) {
    return result.warn("It looks like you didn't end your @import statement correctly. " + "Child nodes are attached to it.", { node: atRule });
  }

  var params = valueParser(atRule.params).nodes;
  var stmt = {
    type: "import",
    node: atRule
  };

  if (!params.length || (params[0].type !== "string" || !params[0].value) && (params[0].type !== "function" || params[0].value !== "url" || !params[0].nodes.length || !params[0].nodes[0].value)) {
    return result.warn("Unable to find uri in '" + atRule.toString() + "'", { node: atRule });
  }

  if (params[0].type === "string") stmt.uri = params[0].value;else stmt.uri = params[0].nodes[0].value;

  stmt.fullUri = stringify(params[0]);

  return stmt;
}

function SmartImport(options) {
  options = assign({
    root: process.cwd(),
    path: [],
    skipDuplicates: true,
    resolve: resolveId,
    load: loadContent,
    plugins: []
  }, options);

  options.root = path.resolve(options.root);

  // convert string to an array of a single element
  if (typeof options.path === "string") options.path = [options.path];

  if (!Array.isArray(options.path)) options.path = [];

  options.path = options.path.map(function (p) {
    return path.resolve(options.root, p);
  });

  return function (styles, result) {
    var state = {
      importedFiles: {},
      hashFiles: {}
    };

    if (styles.source && styles.source.input && styles.source.input.file) state.importedFiles[styles.source.input.file] = {};

    if (options.plugins && !Array.isArray(options.plugins)) throw new Error("plugins option must be an array");

    return parseStyles(result, styles, options, state, []).then(function (bundle) {
      applyRaws(bundle);
      applyStyles(bundle, styles);

      if (_typeof(options.addDependencyTo) === "object" && typeof options.addDependencyTo.addDependency === "function") _Object$keys(state.importedFiles).forEach(options.addDependencyTo.addDependency);

      if (typeof options.onImport === "function") options.onImport(_Object$keys(state.importedFiles));
    });
  };
}

function applyRaws(bundle) {
  bundle.forEach(function (stmt, index) {
    if (index === 0) return;

    if (stmt.parent) {
      var before = stmt.parent.node.raws.before;
      if (stmt.type === "nodes") stmt.nodes[0].raws.before = before;else stmt.node.raws.before = before;
    } else if (stmt.type === "nodes") {
      stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || "\n";
    }
  });
}

function applyStyles(bundle, styles) {
  styles.nodes = [];

  bundle.forEach(function (stmt) {
    if (stmt.type === "import") {
      stmt.node.parent = undefined;
      styles.append(stmt.node);
    } else if (stmt.type === "media") {
      stmt.node.parent = undefined;
      styles.append(stmt.node);
    } else if (stmt.type === "nodes") {
      stmt.nodes.forEach(function (node) {
        node.parent = undefined;
        styles.append(node);
      });
    }
  });
}

function parseStyles(result, styles, options, state, media) {
  var statements = parseStatements(result, styles);

  return _Promise.resolve(statements).then(promiseEach(function (stmt) {
    // skip protocol base uri (protocol://url) or protocol-relative
    if (stmt.type !== "import" || /^(?:[a-z]+:)?\/\//i.test(stmt.uri)) return;else return resolveImportId(result, stmt, options, state);
  })).then(function () {
    var imports = [];
    var bundle = [];

    // squash statements and their children
    statements.forEach(function (stmt) {
      if (stmt.type === "import") {
        if (stmt.children) {
          stmt.children.forEach(function (child, index) {
            if (child.type === "import") imports.push(child);else bundle.push(child);

            // For better output
            if (index === 0) child.parent = stmt;
          });
        } else {
          imports.push(stmt);
        }
      } else if (stmt.type === "media" || stmt.type === "nodes") {
        bundle.push(stmt);
      }
    });

    return imports.concat(bundle);
  });
}

function resolveImportId(result, stmt, options, state) {
  var atRule = stmt.node;
  var base = atRule.source && atRule.source.input && atRule.source.input.file ? path.dirname(atRule.source.input.file) : options.root;

  return _Promise.resolve(options.resolve(stmt.uri, base, options)).then(function (resolved) {
    if (!Array.isArray(resolved)) resolved = [resolved];

    return _Promise.all(resolved.map(function (file) {
      return loadImportContent(result, stmt, file, options, state);
    }));
  }).then(function (result) {
    // Merge loaded statements
    stmt.children = result.reduce(function (result, statements) {
      if (statements) {
        result = result.concat(statements);
      }
      return result;
    }, []);
  }).catch(function (err) {
    result.warn(err.message, { node: atRule });
  });
}

function loadImportContent(result, stmt, filename, options, state) {
  var atRule = stmt.node;
  if (options.skipDuplicates) {
    // skip files already imported at the same scope
    if (state.importedFiles[filename]) return;

    // save imported files to skip them next time
    state.importedFiles[filename] = true;
  }

  return _Promise.resolve(options.load(filename, options)).then(function (content) {
    if (typeof options.transform !== "function") {
      return content;
    }
    return _Promise.resolve(options.transform(content, filename, options)).then(function (transformed) {
      return typeof transformed === "string" ? transformed : content;
    });
  }).then(function (content) {
    if (content.trim() === "") {
      result.warn(filename + " is empty", { node: atRule });
      return;
    }

    // skip previous imported files not containing @import rules
    if (state.hashFiles[content]) return;

    return postcss(options.plugins).process(content, {
      from: filename,
      syntax: result.opts.syntax,
      parser: result.opts.parser
    }).then(function (importedResult) {
      var styles = importedResult.root;
      result.messages = result.messages.concat(importedResult.messages);

      if (options.skipDuplicates) {
        var hasImport = styles.some(function (child) {
          return child.type === "atrule" && child.name === "import";
        });

        if (!hasImport) state.hashFiles[content] = true;
      }

      result.messages.push({
        type: "dependency",
        file: filename
      });

      // recursion: import @import from imported file
      return parseStyles(result, styles, options, state);
    });
  });
}

var index = postcss.plugin("postcss-smart-import", SmartImport);

export default index;
//# sourceMappingURL=index.es.js.map
